" Plug =========================================================================
  set nocompatible
  filetype off

  call plug#begin('~/.dotfiles/vendor/nplugged')

  " Visual
  Plug 'chriskempson/base16-vim'
  Plug 'itchyny/lightline.vim'

  " Source Control
  Plug 'tpope/vim-fugitive'
  Plug 'airblade/vim-gitgutter'

  " Editor
  Plug 'benekastah/neomake'

" Conditional ===================================================================
  au BufRead,BufNewFile {*.md,*.markdown} set filetype=markdown
  au BufNewFile,BufRead {Gemfile,Rakefile,Vagrantfile,Thorfile,config.ru,compass.config} set ft=ruby
  au BufNewFile,BufRead {*.json,*jshintrc,*tern-project,*jscsrc} set ft=json
  au BufNewFile,BufRead {*.es6} set ft=javascript
  au BufNewFile,BufRead {*gitconfig} set ft=gitconfig
  au BufNewFile,BufRead {*.hbs,*.handlebars} set ft=mustache
  au BufNewFile,BufRead {*Dockerfile} set filetype=dockerfile
  au BufNewFile,BufRead {*.coffee,*.litcoffee} set filetype=coffee
  au BufNewFile,BufRead {*.jade} set filetype=jade
  au BufNewFile,BufRead {*zshrc,*zshenv} set filetype=zsh.sh
  au BufNewFile,BufRead {.env} set filetype=sh

  call plug#end()
  filetype plugin indent on

" Autocommands
  au FileType make set noexpandtab
  au FileType gitconfig set noexpandtab
  au FileType javascript setlocal omnifunc=tern#Complete
  au FileType css setlocal omnifunc=csscomplete#CompleteCSS
  au FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
  au FileType python setlocal omnifunc=pythoncomplete#Complete
  au FileType xml setlocal omnifunc=xmlcomplete#CompleteTags
  au FileType gitcommit setlocal omnifunc=pickler#omnifunc

  autocmd! BufWritePost *.py,*.js Neomake

" Settings =====================================================================
  let mapleader = ","

  set encoding=utf-8
  set laststatus=2
  set mouse=a
  set ttymouse=xterm2
  set ffs=unix,dos,mac
  set clipboard=unnamed
  set autoread
  set hidden
  set ruler
  set number
  set title
  set backspace=indent,eol,start
  set nostartofline
  set colorcolumn=80
  set nofoldenable
  set tabstop=2
  set shiftwidth=2
  set softtabstop=2
  set expandtab
  set autoindent
  set copyindent
  set pastetoggle=<F2>
  set list
  set listchars=trail:·,tab:⇥ᐧ
  "set listchars=trail:␣,tab:⇥ᐧ,nbsp:⍽,eol:¶,extends:▸,precedes:◂
  set wrap
  set linebreak
  set nolist
  set breakindent
  set showbreak=\ \...
  set wmh=0
  set background=dark
  set lazyredraw
  set hlsearch
  set incsearch
  set ignorecase
  set smartcase
  set gdefault
  set wildignore+=.git\*,.hg\*,.svn\*
  set nobackup
  set nowb
  set noswapfile
  set spellfile=$HOME/.dotfiles/vim/spellfile.utf-8.add

  filetype plugin on
  filetype indent on
  syntax enable
  let base16colorspace=256
  colorscheme base16-tomorrow

" plugin settings ==============================================================
  " neomake
  let g:neomake_error_sign = {
      \ 'text': '✕',
      \ 'texthl': 'ErrorMsg',
      \ }
  let g:neomake_warning_sign = {
      \ 'text': '▵',
      \ 'texthl': 'WarningMsg',
      \ }
  hi WarningMsg ctermfg=3 ctermbg=18
  hi ErrorMsg ctermfg=1 ctermbg=18

  " lightline
  function! MyModified()
    if &filetype == "help"
      return ""
    elseif &modified
      return "+"
    elseif &modifiable
      return ""
    else
      return ""
    endif
  endfunction

  function! MyReadonly()
    if &filetype == "help"
      return ""
    elseif &readonly
      return ""
    else
      return ""
    endif
  endfunction

  function! MyFugitive()
    try
      if expand('%:t') !~? 'Tagbar\|Gundo' && exists('*fugitive#head')
        let mark = ' '
        let _ = fugitive#head()
        return strlen(_) ? mark._ : ''
      endif
    catch
    endtry
    return ''
  endfunction

  function! MyFilename()
    return ('' != MyReadonly() ? MyReadonly() . ' ' : '') .
           \ ('' != expand('%:t') ? expand('%:t') : '[No Name]') .
           \ ('' != MyModified() ? ' ' . MyModified() : '')
  endfunction

  function! MyCtrlPMark()
    if expand('%:t') =~ 'ControlP'
      call lightline#link('iR'[g:lightline.ctrlp_regex])
      return lightline#concatenate([g:lightline.ctrlp_prev, g:lightline.ctrlp_item
            \ , g:lightline.ctrlp_next], 0)
    else
      return ''
    endif
  endfunction

  " lightline ctrlp
  let g:ctrlp_status_func = {
    \ 'main': 'CtrlPStatusFunc_1',
    \ 'prog': 'CtrlPStatusFunc_2',
    \ }
  function! CtrlPStatusFunc_1(focus, byfname, regex, prev, item, next, marked)
    let g:lightline.ctrlp_regex = a:regex
    let g:lightline.ctrlp_prev = a:prev
    let g:lightline.ctrlp_item = a:item
    let g:lightline.ctrlp_next = a:next
    return lightline#statusline(0)
  endfunction
  function! CtrlPStatusFunc_2(str)
    return lightline#statusline(0)
  endfunction

  " lightline
  function! MyFileformat()
    return winwidth(0) > 70 ? &fileformat : ''
  endfunction

  function! MyFiletype()
    return winwidth(0) > 70 ? (strlen(&filetype) ? &filetype : 'no ft') : ''
  endfunction

  function! MyFileencoding()
    return winwidth(0) > 70 ? (strlen(&fenc) ? &fenc : &enc) : ''
  endfunction

  let g:lightline = {
    \ 'colorscheme': 'jellybeans',
    \ 'active': {
    \   'left': [ [ 'mode', 'paste' ], [ 'fugitive', 'filename' ], ['ctrlpmark'] ],
    \   'right': [ [ 'lineinfo' ], ['percent'], [ 'fileformat', 'fileencoding', 'filetype' ] ]
    \ },
    \ 'component_function': {
    \   'fugitive': 'MyFugitive',
    \   'filename': 'MyFilename',
    \   'fileformat': 'MyFileformat',
    \   'filetype': 'MyFiletype',
    \   'readonly': 'MyReadonly',
    \   'fileencoding': 'MyFileencoding',
    \   'ctrlpmark': 'MyCtrlPMark',
    \   'modified': 'MyModified',
    \ },
    \   'separator': { 'left': '', 'right': '' },
    \   'subseparator': { 'left': '', 'right': '' }
    \ }
